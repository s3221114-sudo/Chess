<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#1e293b">
    <title>–®–∞—Ö–º–∞—Ç—ã Ultra Pro</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow-x: hidden;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        * {
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">

const ChessGame = () => {
  const initialBoard = [
    ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
    ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
    [null, null, null, null, null, null, null, null],
    [null, null, null, null, null, null, null, null],
    [null, null, null, null, null, null, null, null],
    [null, null, null, null, null, null, null, null],
    ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
    ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
  ];

  const [board, setBoard] = useState(initialBoard);
  const [selectedSquare, setSelectedSquare] = useState(null);
  const [currentPlayer, setCurrentPlayer] = useState('white');
  const [gameHistory, setGameHistory] = useState([]);
  const [gameStatus, setGameStatus] = useState('');
  const [castlingRights, setCastlingRights] = useState({
    whiteKingSide: true, whiteQueenSide: true,
    blackKingSide: true, blackQueenSide: true
  });
  const [enPassantTarget, setEnPassantTarget] = useState(null);
  const [isCheck, setIsCheck] = useState(false);
  const [playWithBot, setPlayWithBot] = useState(false);
  const [gameMode, setGameMode] = useState(null);
  const [halfMoveClock, setHalfMoveClock] = useState(0);
  const [showPromotionDialog, setShowPromotionDialog] = useState(null);
  const [validMoves, setValidMoves] = useState([]);
  const [botDifficulty, setBotDifficulty] = useState('medium');
  const [playerColor, setPlayerColor] = useState('white');
  const [boardTheme, setBoardTheme] = useState('classic');
  const [pieceStyle, setPieceStyle] = useState('classic');
  const [showHints, setShowHints] = useState(true);
  const [soundEnabled, setSoundEnabled] = useState(true);
  const [showSettings, setShowSettings] = useState(false);
  const [moveAnalysis, setMoveAnalysis] = useState([]);
  const [showAnalysis, setShowAnalysis] = useState(false);
  const [currentOpening, setCurrentOpening] = useState('');
  const [showOpenings, setShowOpenings] = useState(false);
  const [trainerMode, setTrainerMode] = useState(false);
  const [trainerHint, setTrainerHint] = useState('');
  const [phaseScores, setPhaseScores] = useState({ opening: 0, middlegame: 0, endgame: 0 });

  const pieceSymbols = {
    classic: {
      'K': '‚ôî', 'Q': '‚ôï', 'R': '‚ôñ', 'B': '‚ôó', 'N': '‚ôò', 'P': '‚ôô',
      'k': '‚ôö', 'q': '‚ôõ', 'r': '‚ôú', 'b': '‚ôù', 'n': '‚ôû', 'p': '‚ôü'
    },
    modern: {
      'K': 'ü§¥', 'Q': 'üë∏', 'R': 'üè∞', 'B': '‚õ™', 'N': 'üê¥', 'P': 'üßë',
      'k': 'ü§¥üèø', 'q': 'üë∏üèø', 'r': 'üèØ', 'b': 'üïå', 'n': 'üêé', 'p': 'üßëüèø'
    },
    minimal: {
      'K': 'K', 'Q': 'Q', 'R': 'R', 'B': 'B', 'N': 'N', 'P': 'P',
      'k': 'k', 'q': 'q', 'r': 'r', 'b': 'b', 'n': 'n', 'p': 'p'
    }
  };

  const currentPieceSet = pieceSymbols[pieceStyle];

  const botPersonalities = {
    beginner: { name: '–ù–æ–≤–∏—á–æ–∫', rating: 400, accuracy: 0.3, blunderChance: 0.4, depth: 1 },
    easy: { name: '–õ—ë–≥–∫–∏–π', rating: 800, accuracy: 0.5, blunderChance: 0.25, depth: 1 },
    medium: { name: '–°—Ä–µ–¥–Ω–∏–π', rating: 1200, accuracy: 0.7, blunderChance: 0.15, depth: 2 },
    hard: { name: '–°–ª–æ–∂–Ω—ã–π', rating: 1600, accuracy: 0.85, blunderChance: 0.08, depth: 2 },
    expert: { name: '–≠–∫—Å–ø–µ—Ä—Ç', rating: 2000, accuracy: 0.92, blunderChance: 0.03, depth: 3 },
    magnus: { name: '–ú–∞–≥–Ω—É—Å –ö–∞—Ä–ª—Å–µ–Ω', rating: 2900, accuracy: 0.98, blunderChance: 0.01, depth: 3 }
  };

  const themes = {
    classic: { light: 'bg-amber-100', dark: 'bg-amber-700', name: '–ö–ª–∞—Å—Å–∏–∫–∞' },
    blue: { light: 'bg-blue-100', dark: 'bg-blue-600', name: '–°–∏–Ω—è—è' },
    green: { light: 'bg-green-100', dark: 'bg-green-600', name: '–ó–µ–ª—ë–Ω–∞—è' },
    purple: { light: 'bg-purple-100', dark: 'bg-purple-600', name: '–§–∏–æ–ª–µ—Ç–æ–≤–∞—è' },
    wooden: { light: 'bg-orange-100', dark: 'bg-orange-800', name: '–î–µ—Ä–µ–≤—è–Ω–Ω–∞—è' },
    dark: { light: 'bg-slate-600', dark: 'bg-slate-900', name: '–¢—ë–º–Ω–∞—è' }
  };

  const openingsDatabase = {
    'e2e4': {
      name: '–ö–æ—Ä–æ–ª–µ–≤—Å–∫–∏–π –¥–µ–±—é—Ç (e4)',
      description: '–°–∞–º—ã–π –ø–æ–ø—É–ª—è—Ä–Ω—ã–π –ø–µ—Ä–≤—ã–π —Ö–æ–¥. –û—Ç–∫—Ä—ã–≤–∞–µ—Ç –ª–∏–Ω–∏–∏ –¥–ª—è —Å–ª–æ–Ω–∞ –∏ —Ñ–µ—Ä–∑—è.',
      moves: { 'e7e5': '–û—Ç–∫—Ä—ã—Ç—ã–µ –¥–µ–±—é—Ç—ã', 'c7c5': '–°–∏—Ü–∏–ª–∏–∞–Ω—Å–∫–∞—è –∑–∞—â–∏—Ç–∞', 'e7e6': '–§—Ä–∞–Ω—Ü—É–∑—Å–∫–∞—è –∑–∞—â–∏—Ç–∞', 'c7c6': '–ó–∞—â–∏—Ç–∞ –ö–∞—Ä–æ-–ö–∞–Ω–Ω' }
    },
    'd2d4': {
      name: '–§–µ—Ä–∑–µ–≤—ã–π –¥–µ–±—é—Ç (d4)',
      description: '–ö–æ–Ω—Ç—Ä–æ–ª—å —Ü–µ–Ω—Ç—Ä–∞ —Å —Ñ–µ—Ä–∑–µ–≤–æ–≥–æ —Ñ–ª–∞–Ω–≥–∞.',
      moves: { 'd7d5': '–ó–∞–∫—Ä—ã—Ç—ã–µ –¥–µ–±—é—Ç—ã', 'g8f6': '–ò–Ω–¥–∏–π—Å–∫–∏–µ –∑–∞—â–∏—Ç—ã' }
    },
    'e2e4e7e5': {
      name: '–û—Ç–∫—Ä—ã—Ç—ã–µ –¥–µ–±—é—Ç—ã',
      description: '–ö–ª–∞—Å—Å–∏—á–µ—Å–∫–∞—è –±–æ—Ä—å–±–∞ –∑–∞ —Ü–µ–Ω—Ç—Ä.',
      moves: { 'g1f3': '–î–µ–±—é—Ç –∫–æ–Ω—è', 'f2f4': '–ö–æ—Ä–æ–ª–µ–≤—Å–∫–∏–π –≥–∞–º–±–∏—Ç', 'f1c4': '–ò—Ç–∞–ª—å—è–Ω—Å–∫–∞—è –ø–∞—Ä—Ç–∏—è' }
    },
    'e2e4e7e5g1f3': {
      name: '–î–µ–±—é—Ç –∫–æ–Ω—è',
      description: '–†–∞–∑–≤–∏—Ç–∏–µ —Å –∞—Ç–∞–∫–æ–π –Ω–∞ –ø–µ—à–∫—É e5.',
      moves: { 'b8c6': '–ó–∞—â–∏—Ç–∞ –ü–µ—Ç—Ä–æ–≤–∞', 'g8f6': '–†—É—Å—Å–∫–∞—è –ø–∞—Ä—Ç–∏—è' }
    },
    'e2e4e7e5g1f3b8c6f1c4': {
      name: '–ò—Ç–∞–ª—å—è–Ω—Å–∫–∞—è –ø–∞—Ä—Ç–∏—è',
      description: '–ö–ª–∞—Å—Å–∏—á–µ—Å–∫–∏–π –∞—Ç–∞–∫—É—é—â–∏–π –¥–µ–±—é—Ç.',
      moves: { 'f8c5': '–î–∂–æ–∫–æ –ü–∏–∞–Ω–æ', 'g8f6': '–ó–∞—â–∏—Ç–∞ –¥–≤—É—Ö –∫–æ–Ω–µ–π' }
    },
    'e2e4c7c5': {
      name: '–°–∏—Ü–∏–ª–∏–∞–Ω—Å–∫–∞—è –∑–∞—â–∏—Ç–∞',
      description: '–ê—Å–∏–º–º–µ—Ç—Ä–∏—á–Ω—ã–π –¥–µ–±—é—Ç —Å —à–∞–Ω—Å–∞–º–∏ –Ω–∞ –∫–æ–Ω—Ç—Ä–∏–≥—Ä—É.',
      moves: { 'g1f3': '–û—Ç–∫—Ä—ã—Ç–∞—è —Å–∏—Ü–∏–ª–∏–∞–Ω—Å–∫–∞—è', 'b1c3': '–ó–∞–∫—Ä—ã—Ç–∞—è —Å–∏—Ü–∏–ª–∏–∞–Ω—Å–∫–∞—è' }
    },
    'd2d4d7d5c2c4': {
      name: '–§–µ—Ä–∑–µ–≤—ã–π –≥–∞–º–±–∏—Ç',
      description: '–ë–æ—Ä—å–±–∞ –∑–∞ —Ü–µ–Ω—Ç—Ä —Å –ø–æ–º–æ—â—å—é –ø–µ—à–∫–∏ c4.',
      moves: { 'e7e6': '–ü—Ä–∏–Ω—è—Ç—ã–π –≤–∞—Ä–∏–∞–Ω—Ç', 'd5c4': '–û—Ç–∫–∞–∑–∞–Ω–Ω—ã–π –≤–∞—Ä–∏–∞–Ω—Ç' }
    }
  };

  const trainerMessages = {
    goodMove: [
      '–û—Ç–ª–∏—á–Ω—ã–π —Ö–æ–¥! üëç',
      '–ò–º–µ–Ω–Ω–æ —Ç–∞–∫! üéØ',
      '–ü—Ä–µ–∫—Ä–∞—Å–Ω–∞—è –∏–≥—Ä–∞! ‚≠ê',
      '–°–∏–ª—å–Ω—ã–π —Ö–æ–¥! üí™',
      '–í—ã –Ω–∞ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–º –ø—É—Ç–∏! üéì'
    ],
    blunder: [
      '–û—Å—Ç–æ—Ä–æ–∂–Ω–æ! –≠—Ç–æ—Ç —Ö–æ–¥ –æ—Å–ª–∞–±–ª—è–µ—Ç –≤–∞—à—É –ø–æ–∑–∏—Ü–∏—é.',
      '–ü–æ–¥—É–º–∞–π—Ç–µ –µ—â—ë —Ä–∞–∑. –ï—Å—Ç—å –±–æ–ª–µ–µ —Å–∏–ª—å–Ω—ã–π —Ö–æ–¥.',
      '–≠—Ç–æ –º–æ–∂–µ—Ç –ø—Ä–∏–≤–µ—Å—Ç–∏ –∫ –ø–æ—Ç–µ—Ä–µ –º–∞—Ç–µ—Ä–∏–∞–ª–∞.',
      '–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –∑–∞—â–∏—Ç–∏—Ç—å –≤–∞—à–∏ —Ñ–∏–≥—É—Ä—ã.'
    ],
    hint: [
      '–û–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ –Ω–∞ —Ü–µ–Ω—Ç—Ä –¥–æ—Å–∫–∏.',
      '–ù–µ –∑–∞–±—ã–≤–∞–π—Ç–µ –æ —Ä–∞–∑–≤–∏—Ç–∏–∏ —Ñ–∏–≥—É—Ä.',
      '–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å –≤–∞—à–µ–≥–æ –∫–æ—Ä–æ–ª—è.',
      '–ò—â–∏—Ç–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –∞—Ç–∞–∫–∏.',
      '–ö–æ–Ω—Ç—Ä–æ–ª–∏—Ä—É–π—Ç–µ –≤–∞–∂–Ω—ã–µ –ø–æ–ª—è.'
    ]
  };

  const playSound = (type) => {
    if (!soundEnabled) return;
    try {
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      if (type === 'move') {
        oscillator.frequency.value = 500;
        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
      } else if (type === 'capture') {
        oscillator.frequency.value = 300;
        gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
      } else if (type === 'check') {
        oscillator.frequency.value = 800;
        gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
      } else if (type === 'good') {
        oscillator.frequency.value = 600;
        gainNode.gain.setValueAtTime(0.12, audioContext.currentTime);
      } else if (type === 'bad') {
        oscillator.frequency.value = 200;
        gainNode.gain.setValueAtTime(0.18, audioContext.currentTime);
      }
      
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + 0.15);
    } catch (e) {
      console.log('Audio not supported');
    }
  };

  const isWhitePiece = (piece) => piece && piece === piece.toUpperCase();
  const isBlackPiece = (piece) => piece && piece === piece.toLowerCase();
  const deepCopyBoard = (board) => board.map(row => [...row]);

  const findKing = (board, isWhite) => {
    const king = isWhite ? 'K' : 'k';
    for (let row = 0; row < 8; row++) {
      for (let col = 0; col < 8; col++) {
        if (board[row][col] === king) return [row, col];
      }
    }
    return null;
  };

  const isSquareUnderAttack = (board, row, col, byWhite) => {
    for (let r = 0; r < 8; r++) {
      for (let c = 0; c < 8; c++) {
        const piece = board[r][c];
        if (!piece) continue;
        if (byWhite && !isWhitePiece(piece)) continue;
        if (!byWhite && !isBlackPiece(piece)) continue;
        if (canPieceMove(board, r, c, row, col, null, true)) return true;
      }
    }
    return false;
  };

  const isInCheck = (board, isWhite) => {
    const kingPos = findKing(board, isWhite);
    if (!kingPos) return false;
    return isSquareUnderAttack(board, kingPos[0], kingPos[1], !isWhite);
  };

  const isPathClear = (board, fromRow, fromCol, toRow, toCol) => {
    const rowStep = toRow > fromRow ? 1 : toRow < fromRow ? -1 : 0;
    const colStep = toCol > fromCol ? 1 : toCol < fromCol ? -1 : 0;
    let currentRow = fromRow + rowStep;
    let currentCol = fromCol + colStep;
    while (currentRow !== toRow || currentCol !== toCol) {
      if (board[currentRow][currentCol] !== null) return false;
      currentRow += rowStep;
      currentCol += colStep;
    }
    return true;
  };

  const canPieceMove = (board, fromRow, fromCol, toRow, toCol, enPassant, ignoreCheck = false) => {
    const piece = board[fromRow][fromCol];
    const target = board[toRow][toCol];
    
    if (!piece) return false;
    if (target && ((isWhitePiece(piece) && isWhitePiece(target)) || 
                   (isBlackPiece(piece) && isBlackPiece(target)))) return false;

    const rowDiff = toRow - fromRow;
    const colDiff = toCol - fromCol;
    const absRowDiff = Math.abs(rowDiff);
    const absColDiff = Math.abs(colDiff);
    const pieceLower = piece.toLowerCase();
    let validMove = false;

    switch (pieceLower) {
      case 'p':
        const direction = isWhitePiece(piece) ? -1 : 1;
        const startRow = isWhitePiece(piece) ? 6 : 1;
        if (colDiff === 0 && !target) {
          if (rowDiff === direction) validMove = true;
          if (fromRow === startRow && rowDiff === 2 * direction && !board[fromRow + direction][fromCol]) validMove = true;
        }
        if (absColDiff === 1 && rowDiff === direction) {
          if (target) validMove = true;
          if (enPassant && enPassant[0] === toRow && enPassant[1] === toCol) validMove = true;
        }
        break;
      case 'n':
        validMove = (absRowDiff === 2 && absColDiff === 1) || (absRowDiff === 1 && absColDiff === 2);
        break;
      case 'b':
        if (absRowDiff === absColDiff) validMove = isPathClear(board, fromRow, fromCol, toRow, toCol);
        break;
      case 'r':
        if (rowDiff === 0 || colDiff === 0) validMove = isPathClear(board, fromRow, fromCol, toRow, toCol);
        break;
      case 'q':
        if (rowDiff === 0 || colDiff === 0 || absRowDiff === absColDiff) {
          validMove = isPathClear(board, fromRow, fromCol, toRow, toCol);
        }
        break;
      case 'k':
        validMove = absRowDiff <= 1 && absColDiff <= 1;
        break;
    }

    if (!validMove) return false;
    if (ignoreCheck) return true;

    const testBoard = deepCopyBoard(board);
    testBoard[toRow][toCol] = testBoard[fromRow][fromCol];
    testBoard[fromRow][fromCol] = null;

    if (pieceLower === 'p' && enPassant && enPassant[0] === toRow && enPassant[1] === toCol) {
      const captureRow = isWhitePiece(piece) ? toRow + 1 : toRow - 1;
      testBoard[captureRow][toCol] = null;
    }

    return !isInCheck(testBoard, isWhitePiece(piece));
  };

  const canCastle = (board, isWhite, kingSide, rights) => {
    const row = isWhite ? 7 : 0;
    const king = isWhite ? 'K' : 'k';
    
    if (board[row][4] !== king) return false;
    if (isInCheck(board, isWhite)) return false;

    if (kingSide) {
      if (!rights[isWhite ? 'whiteKingSide' : 'blackKingSide']) return false;
      if (board[row][5] !== null || board[row][6] !== null) return false;
      if (board[row][7] === null) return false;
      if (isSquareUnderAttack(board, row, 5, !isWhite)) return false;
      if (isSquareUnderAttack(board, row, 6, !isWhite)) return false;
      return true;
    } else {
      if (!rights[isWhite ? 'whiteQueenSide' : 'blackQueenSide']) return false;
      if (board[row][1] !== null || board[row][2] !== null || board[row][3] !== null) return false;
      if (board[row][0] === null) return false;
      if (isSquareUnderAttack(board, row, 2, !isWhite)) return false;
      if (isSquareUnderAttack(board, row, 3, !isWhite)) return false;
      return true;
    }
  };

  const getAllLegalMoves = (board, isWhite, enPassant, rights) => {
    const moves = [];
    for (let fromRow = 0; fromRow < 8; fromRow++) {
      for (let fromCol = 0; fromCol < 8; fromCol++) {
        const piece = board[fromRow][fromCol];
        if (!piece) continue;
        if (isWhite && !isWhitePiece(piece)) continue;
        if (!isWhite && !isBlackPiece(piece)) continue;

        for (let toRow = 0; toRow < 8; toRow++) {
          for (let toCol = 0; toCol < 8; toCol++) {
            if (canPieceMove(board, fromRow, fromCol, toRow, toCol, enPassant)) {
              moves.push({ fromRow, fromCol, toRow, toCol, piece: board[fromRow][fromCol], capture: board[toRow][toCol] });
            }
          }
        }

        if (piece.toLowerCase() === 'k') {
          if (canCastle(board, isWhite, true, rights)) {
            moves.push({ fromRow, fromCol, toRow: fromRow, toCol: 6, isCastling: true });
          }
          if (canCastle(board, isWhite, false, rights)) {
            moves.push({ fromRow, fromCol, toRow: fromRow, toCol: 2, isCastling: true });
          }
        }
      }
    }
    return moves;
  };

  const evaluatePosition = (board) => {
    const pieceValues = { p: 1, n: 3, b: 3, r: 5, q: 9, k: 0 };
    let score = 0;
    
    for (let row = 0; row < 8; row++) {
      for (let col = 0; col < 8; col++) {
        const piece = board[row][col];
        if (piece) {
          const value = pieceValues[piece.toLowerCase()];
          let positionBonus = 0;
          
          // –ë–æ–Ω—É—Å –∑–∞ –∫–æ–Ω—Ç—Ä–æ–ª—å —Ü–µ–Ω—Ç—Ä–∞
          if ((row === 3 || row === 4) && (col === 3 || col === 4)) {
            positionBonus = 0.3;
          }
          
          // –ë–æ–Ω—É—Å –∑–∞ —Ä–∞–∑–≤–∏—Ç–∏–µ
          if (piece.toLowerCase() === 'n' || piece.toLowerCase() === 'b') {
            if ((isWhitePiece(piece) && row < 6) || (isBlackPiece(piece) && row > 1)) {
              positionBonus += 0.2;
            }
          }
          
          score += isWhitePiece(piece) ? -(value + positionBonus) : (value + positionBonus);
        }
      }
    }
    return score;
  };

  const analyzeMoveQuality = (prevBoard, newBoard, move) => {
    const prevEval = evaluatePosition(prevBoard);
    const newEval = evaluatePosition(newBoard);
    const evalChange = newEval - prevEval;
    
    // –î–ª—è –±–µ–ª—ã—Ö: –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ = —Ö–æ—Ä–æ—à–æ (–æ–Ω–∏ —É–º–µ–Ω—å—à–∞—é—Ç –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—É—é –æ—Ü–µ–Ω–∫—É)
    // –î–ª—è —á—ë—Ä–Ω—ã—Ö: –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–æ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ = —Ö–æ—Ä–æ—à–æ (–æ–Ω–∏ —É–≤–µ–ª–∏—á–∏–≤–∞—é—Ç –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—É—é –æ—Ü–µ–Ω–∫—É)
    const isGoodMove = move.player === 'white' ? evalChange > 0 : evalChange < 0;
    const absChange = Math.abs(evalChange);
    
    let quality = 'good';
    let emoji = '‚úì';
    let description = '–•–æ—Ä–æ—à–∏–π —Ö–æ–¥';
    
    if (absChange > 3) {
      quality = isGoodMove ? 'brilliant' : 'blunder';
      emoji = isGoodMove ? '!!' : '??';
      description = isGoodMove ? '–ë–ª–µ—Å—Ç—è—â–∏–π —Ö–æ–¥!' : '–ì—Ä—É–±–∞—è –æ—à–∏–±–∫–∞!';
    } else if (absChange > 1.5) {
      quality = isGoodMove ? 'great' : 'mistake';
      emoji = isGoodMove ? '!' : '?';
      description = isGoodMove ? '–û—Ç–ª–∏—á–Ω—ã–π —Ö–æ–¥!' : '–û—à–∏–±–∫–∞';
    } else if (absChange > 0.5) {
      quality = isGoodMove ? 'good' : 'inaccuracy';
      emoji = isGoodMove ? '‚úì' : '?!';
      description = isGoodMove ? '–•–æ—Ä–æ—à–∏–π —Ö–æ–¥' : '–ù–µ—Ç–æ—á–Ω–æ—Å—Ç—å';
    }
    
    return { quality, emoji, description, evalChange };
  };

  const getGamePhase = (moveCount) => {
    if (moveCount <= 10) return 'opening';
    if (moveCount <= 30) return 'middlegame';
    return 'endgame';
  };

  const updatePhaseScores = (analysis) => {
    const scores = { opening: 0, middlegame: 0, endgame: 0 };
    const counts = { opening: 0, middlegame: 0, endgame: 0 };
    
    analysis.forEach((move, index) => {
      const phase = getGamePhase(index);
      const qualityScore = {
        'brilliant': 10,
        'great': 8,
        'good': 6,
        'book': 7,
        'inaccuracy': 4,
        'mistake': 2,
        'blunder': 0
      };
      
      scores[phase] += qualityScore[move.quality] || 5;
      counts[phase]++;
    });
    
    const avgScores = {
      opening: counts.opening > 0 ? Math.round(scores.opening / counts.opening) : 0,
      middlegame: counts.middlegame > 0 ? Math.round(scores.middlegame / counts.middlegame) : 0,
      endgame: counts.endgame > 0 ? Math.round(scores.endgame / counts.endgame) : 0
    };
    
    setPhaseScores(avgScores);
  };

  const detectOpening = (history) => {
    const moveString = history.slice(0, Math.min(6, history.length))
      .map(m => {
        const notation = m.notation.replace(/[+#x]/g, '');
        return notation;
      })
      .join('');
    
    let detected = '';
    for (const [key, opening] of Object.entries(openingsDatabase)) {
      if (moveString.includes(key.replace(/[0-9]/g, ''))) {
        detected = opening.name;
      }
    }
    
    return detected || (history.length > 0 ? '–ù–µ—Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –¥–µ–±—é—Ç' : '');
  };

  const getTrainerAdvice = (board, player, lastMove) => {
    const pieces = [];
    for (let row = 0; row < 8; row++) {
      for (let col = 0; col < 8; col++) {
        if (board[row][col]) pieces.push(board[row][col]);
      }
    }
    
    const developedPieces = pieces.filter(p => 
      (p === 'N' || p === 'B') && 
      (isWhitePiece(p) ? true : true)
    ).length;
    
    if (gameHistory.length < 8 && developedPieces < 3) {
      return '–°–æ—Å—Ä–µ–¥–æ—Ç–æ—á—å—Ç–µ—Å—å –Ω–∞ —Ä–∞–∑–≤–∏—Ç–∏–∏ —Ñ–∏–≥—É—Ä. –í—ã–≤–æ–¥–∏—Ç–µ –∫–æ–Ω–µ–π –∏ —Å–ª–æ–Ω–æ–≤.';
    }
    
    if (gameHistory.length < 10 && !castlingRights.whiteKingSide && !castlingRights.whiteQueenSide) {
      return '–ü–æ–¥—É–º–∞–π—Ç–µ –æ —Ä–æ–∫–∏—Ä–æ–≤–∫–µ –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ –∫–æ—Ä–æ–ª—è.';
    }
    
    const legalMoves = getAllLegalMoves(board, player === 'white', enPassantTarget, castlingRights);
    const captureMoves = legalMoves.filter(m => m.capture);
    
    if (captureMoves.length > 0) {
      return '–ï—Å—Ç—å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –≤–∑—è—Ç—å —Ñ–∏–≥—É—Ä—É –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞!';
    }
    
    return trainerMessages.hint[Math.floor(Math.random() * trainerMessages.hint.length)];
  };

  const makeMove = (fromRow, fromCol, toRow, toCol, isCastling = false, promotionPiece = 'q') => {
    const newBoard = deepCopyBoard(board);
    const piece = newBoard[fromRow][fromCol];
    const captured = newBoard[toRow][toCol];
    
    let newEnPassant = null;
    let newRights = { ...castlingRights };
    let moveNotation = '';
    let newHalfMove = halfMoveClock + 1;

    if (piece.toLowerCase() === 'p' || captured) {
      newHalfMove = 0;
    }

    if (isCastling) {
      const row = fromRow;
      newBoard[toRow][toCol] = piece;
      newBoard[fromRow][fromCol] = null;
      
      if (toCol === 6) {
        newBoard[row][5] = newBoard[row][7];
        newBoard[row][7] = null;
        moveNotation = 'O-O';
      } else {
        newBoard[row][3] = newBoard[row][0];
        newBoard[row][0] = null;
        moveNotation = 'O-O-O';
      }

      if (isWhitePiece(piece)) {
        newRights.whiteKingSide = false;
        newRights.whiteQueenSide = false;
      } else {
        newRights.blackKingSide = false;
        newRights.blackQueenSide = false;
      }
      
      playSound('move');
    } else {
      if (piece.toLowerCase() === 'p' && enPassantTarget && 
          enPassantTarget[0] === toRow && enPassantTarget[1] === toCol) {
        const captureRow = isWhitePiece(piece) ? toRow + 1 : toRow - 1;
        newBoard[captureRow][toCol] = null;
        playSound('capture');
      } else if (captured) {
        playSound('capture');
      } else {
        playSound('move');
      }

      newBoard[toRow][toCol] = piece;
      newBoard[fromRow][fromCol] = null;

      if (piece.toLowerCase() === 'p' && (toRow === 0 || toRow === 7)) {
        newBoard[toRow][toCol] = isWhitePiece(piece) ? promotionPiece.toUpperCase() : promotionPiece.toLowerCase();
      }

      if (piece.toLowerCase() === 'p' && Math.abs(toRow - fromRow) === 2) {
        newEnPassant = [isWhitePiece(piece) ? fromRow - 1 : fromRow + 1, fromCol];
      }

      if (piece.toLowerCase() === 'k') {
        if (isWhitePiece(piece)) {
          newRights.whiteKingSide = false;
          newRights.whiteQueenSide = false;
        } else {
          newRights.blackKingSide = false;
          newRights.blackQueenSide = false;
        }
      }
      if (piece.toLowerCase() === 'r') {
        if (fromRow === 7 && fromCol === 0) newRights.whiteQueenSide = false;
        if (fromRow === 7 && fromCol === 7) newRights.whiteKingSide = false;
        if (fromRow === 0 && fromCol === 0) newRights.blackQueenSide = false;
        if (fromRow === 0 && fromCol === 7) newRights.blackKingSide = false;
      }

      const pieceName = piece.toLowerCase() === 'p' ? '' : currentPieceSet[piece];
      const captureSymbol = captured ? 'x' : '';
      moveNotation = `${pieceName}${String.fromCharCode(97 + fromCol)}${8 - fromRow}${captureSymbol}${String.fromCharCode(97 + toCol)}${8 - toRow}`;
    }

    const nextPlayer = currentPlayer === 'white' ? 'black' : 'white';
    const inCheck = isInCheck(newBoard, nextPlayer === 'white');
    const legalMoves = getAllLegalMoves(newBoard, nextPlayer === 'white', newEnPassant, newRights);

    if (inCheck) playSound('check');

    let status = '';
    if (legalMoves.length === 0) {
      if (inCheck) {
        status = `–ú–∞—Ç! ${currentPlayer === 'white' ? '–ë–µ–ª—ã–µ' : '–ß—ë—Ä–Ω—ã–µ'} –ø–æ–±–µ–¥–∏–ª–∏!`;
        moveNotation += '#';
      } else {
        status = '–ü–∞—Ç! –ù–∏—á—å—è!';
      }
    } else if (inCheck) {
      moveNotation += '+';
    }

    if (newHalfMove >= 50) {
      status = '–ù–∏—á—å—è! (50 —Ö–æ–¥–æ–≤ –±–µ–∑ –≤–∑—è—Ç–∏—è)';
    }

    // –ê–Ω–∞–ª–∏–∑ —Ö–æ–¥–∞
    const analysis = analyzeMoveQuality(board, newBoard, { player: currentPlayer, notation: moveNotation });
    const newMoveAnalysis = [...moveAnalysis, { ...analysis, notation: moveNotation, player: currentPlayer }];
    setMoveAnalysis(newMoveAnalysis);
    updatePhaseScores(newMoveAnalysis);
    
    if (trainerMode && currentPlayer === playerColor) {
      if (analysis.quality === 'blunder' || analysis.quality === 'mistake') {
        setTrainerHint(trainerMessages.blunder[Math.floor(Math.random() * trainerMessages.blunder.length)]);
        playSound('bad');
      } else if (analysis.quality === 'brilliant' || analysis.quality === 'great') {
        setTrainerHint(trainerMessages.goodMove[Math.floor(Math.random() * trainerMessages.goodMove.length)]);
        playSound('good');
      } else {
        setTrainerHint('');
      }
    }

    setBoard(newBoard);
    setCastlingRights(newRights);
    setEnPassantTarget(newEnPassant);
    setCurrentPlayer(nextPlayer);
    setIsCheck(inCheck);
    setGameStatus(status);
    setHalfMoveClock(newHalfMove);
    
    const newHistory = [...gameHistory, {
      board: deepCopyBoard(board),
      castlingRights: { ...castlingRights },
      enPassantTarget: enPassantTarget,
      player: currentPlayer,
      notation: moveNotation,
      halfMoveClock: halfMoveClock
    }];
    setGameHistory(newHistory);
    
    setCurrentOpening(detectOpening(newHistory));

    return { newBoard, nextPlayer, status };
  };

  const handleSquareClick = (row, col) => {
    if (gameStatus || (playWithBot && currentPlayer !== playerColor)) return;

    if (selectedSquare) {
      const [fromRow, fromCol] = selectedSquare;
      
      if (fromRow === row && fromCol === col) {
        setSelectedSquare(null);
        setValidMoves([]);
        return;
      }

      const piece = board[fromRow][fromCol];
      
      if (piece && piece.toLowerCase() === 'k' && fromCol === 4 && Math.abs(col - fromCol) === 2) {
        if (canCastle(board, isWhitePiece(piece), col === 6, castlingRights)) {
          makeMove(fromRow, fromCol, row, col, true);
          setSelectedSquare(null);
          setValidMoves([]);
          return;
        }
      }

      if (canPieceMove(board, fromRow, fromCol, row, col, enPassantTarget)) {
        if (piece.toLowerCase() === 'p' && (row === 0 || row === 7)) {
          setShowPromotionDialog({ fromRow, fromCol, toRow: row, toCol: col });
        } else {
          makeMove(fromRow, fromCol, row, col);
          setSelectedSquare(null);
          setValidMoves([]);
        }
      } else {
        const clickedPiece = board[row][col];
        if (clickedPiece && 
            ((currentPlayer === 'white' && isWhitePiece(clickedPiece)) ||
             (currentPlayer === 'black' && isBlackPiece(clickedPiece)))) {
          setSelectedSquare([row, col]);
          calculateValidMoves(row, col);
        } else {
          setSelectedSquare(null);
          setValidMoves([]);
        }
      }
    } else {
      const piece = board[row][col];
      if (piece && 
          ((currentPlayer === 'white' && isWhitePiece(piece)) ||
           (currentPlayer === 'black' && isBlackPiece(piece)))) {
        setSelectedSquare([row, col]);
        calculateValidMoves(row, col);
      }
    }
  };

  const calculateValidMoves = (row, col) => {
    if (!showHints) {
      setValidMoves([]);
      return;
    }
    const moves = [];
    for (let r = 0; r < 8; r++) {
      for (let c = 0; c < 8; c++) {
        if (canPieceMove(board, row, col, r, c, enPassantTarget)) {
          moves.push([r, c]);
        }
      }
    }
    
    const piece = board[row][col];
    if (piece && piece.toLowerCase() === 'k') {
      if (canCastle(board, isWhitePiece(piece), true, castlingRights)) {
        moves.push([row, 6]);
      }
      if (canCastle(board, isWhitePiece(piece), false, castlingRights)) {
        moves.push([row, 2]);
      }
    }
    
    setValidMoves(moves);
  };

  const undoMove = () => {
    if (gameHistory.length === 0) return;
    
    let undoCount = playWithBot ? 2 : 1;
    
    if (gameHistory.length < undoCount) {
      undoCount = gameHistory.length;
    }
    
    const targetIndex = gameHistory.length - undoCount;
    
    if (playWithBot && targetIndex > 0) {
      const targetState = gameHistory[targetIndex];
      if (targetState.player !== playerColor) {
        undoCount = Math.min(undoCount + 1, gameHistory.length);
      }
    }
    
    const finalIndex = gameHistory.length - undoCount;
    const lastState = finalIndex >= 0 ? gameHistory[finalIndex] : {
      board: initialBoard,
      castlingRights: {
        whiteKingSide: true, whiteQueenSide: true,
        blackKingSide: true, blackQueenSide: true
      },
      enPassantTarget: null,
      player: 'white',
      halfMoveClock: 0
    };
    
    setBoard(lastState.board);
    setCastlingRights(lastState.castlingRights);
    setEnPassantTarget(lastState.enPassantTarget);
    setCurrentPlayer(lastState.player);
    setGameHistory(gameHistory.slice(0, finalIndex));
    setMoveAnalysis(moveAnalysis.slice(0, finalIndex));
    setGameStatus('');
    setHalfMoveClock(lastState.halfMoveClock || 0);
    setIsCheck(isInCheck(lastState.board, lastState.player === 'white'));
    setSelectedSquare(null);
    setValidMoves([]);
    setTrainerHint('');
  };

  const makeBotMove = () => {
    const legalMoves = getAllLegalMoves(board, currentPlayer === 'white', enPassantTarget, castlingRights);
    if (legalMoves.length === 0) return;

    const difficulty = botPersonalities[botDifficulty];
    let chosenMove;

    if (Math.random() < difficulty.blunderChance) {
      chosenMove = legalMoves[Math.floor(Math.random() * legalMoves.length)];
    } else if (Math.random() < difficulty.accuracy) {
      const captureMoves = legalMoves.filter(m => m.capture);
      const checkMoves = legalMoves.filter(m => {
        const testBoard = deepCopyBoard(board);
        testBoard[m.toRow][m.toCol] = testBoard[m.fromRow][m.fromCol];
        testBoard[m.fromRow][m.fromCol] = null;
        return isInCheck(testBoard, currentPlayer !== 'white');
      });
      
      if (checkMoves.length > 0 && Math.random() > 0.5) {
        chosenMove = checkMoves[Math.floor(Math.random() * checkMoves.length)];
      } else if (captureMoves.length > 0) {
        captureMoves.sort((a, b) => {
          const pieceValues = { p: 1, n: 3, b: 3, r: 5, q: 9, k: 0 };
          return pieceValues[b.capture.toLowerCase()] - pieceValues[a.capture.toLowerCase()];
        });
        chosenMove = captureMoves[0];
      } else {
        chosenMove = legalMoves[Math.floor(Math.random() * legalMoves.length)];
      }
    } else {
      chosenMove = legalMoves[Math.floor(Math.random() * legalMoves.length)];
    }

    setTimeout(() => {
      makeMove(chosenMove.fromRow, chosenMove.fromCol, chosenMove.toRow, chosenMove.toCol, chosenMove.isCastling);
    }, 500);
  };

  useEffect(() => {
    if (playWithBot && currentPlayer !== playerColor && !gameStatus && !showPromotionDialog) {
      makeBotMove();
    }
  }, [currentPlayer, playWithBot, gameStatus, showPromotionDialog]);

  useEffect(() => {
    if (trainerMode && !playWithBot && gameHistory.length > 0) {
      const advice = getTrainerAdvice(board, currentPlayer, gameHistory[gameHistory.length - 1]);
      setTrainerHint(advice);
    }
  }, [currentPlayer, trainerMode]);

  const startGame = (withBot, color = 'white', difficulty = 'medium', trainer = false) => {
    setGameMode('playing');
    setPlayWithBot(withBot);
    setPlayerColor(color);
    setBotDifficulty(difficulty);
    setTrainerMode(trainer);
    
    if (withBot && color === 'black') {
      setCurrentPlayer('white');
      setTimeout(() => makeBotMove(), 500);
    } else if (withBot && color === 'random') {
      const randomColor = Math.random() > 0.5 ? 'white' : 'black';
      setPlayerColor(randomColor);
      if (randomColor === 'black') {
        setCurrentPlayer('white');
        setTimeout(() => makeBotMove(), 500);
      }
    }
  };

  const resetGame = () => {
    setBoard(initialBoard);
    setSelectedSquare(null);
    setCurrentPlayer('white');
    setGameHistory([]);
    setGameStatus('');
    setCastlingRights({
      whiteKingSide: true, whiteQueenSide: true,
      blackKingSide: true, blackQueenSide: true
    });
    setEnPassantTarget(null);
    setIsCheck(false);
    setGameMode(null);
    setPlayWithBot(false);
    setHalfMoveClock(0);
    setShowPromotionDialog(null);
    setValidMoves([]);
    setPlayerColor('white');
    setMoveAnalysis([]);
    setShowAnalysis(false);
    setCurrentOpening('');
    setTrainerMode(false);
    setTrainerHint('');
    setPhaseScores({ opening: 0, middlegame: 0, endgame: 0 });
  };

  const getPhaseRating = (score) => {
    if (score >= 9) return { text: '–û—Ç–ª–∏—á–Ω–æ', color: 'text-green-600', emoji: '‚≠ê‚≠ê‚≠ê' };
    if (score >= 7) return { text: '–•–æ—Ä–æ—à–æ', color: 'text-blue-600', emoji: '‚≠ê‚≠ê' };
    if (score >= 5) return { text: '–ù–æ—Ä–º–∞–ª—å–Ω–æ', color: 'text-yellow-600', emoji: '‚≠ê' };
    return { text: '–°–ª–∞–±–æ', color: 'text-red-600', emoji: '‚ùå' };
  };

  if (!gameMode) {
    return (
      <div className="flex flex-col items-center justify-center min-h-screen bg-gradient-to-br from-slate-800 to-slate-900 p-4">
        <div className="bg-white rounded-lg shadow-2xl p-8 max-w-2xl w-full">
          <h1 className="text-4xl font-bold text-center mb-6 text-slate-800">‚ôüÔ∏è –®–∞—Ö–º–∞—Ç—ã Ultra Pro ‚ôüÔ∏è</h1>
          
          {!playWithBot && (
            <div>
              <p className="text-center text-slate-600 mb-6">–í—ã–±–µ—Ä–∏—Ç–µ —Ä–µ–∂–∏–º –∏–≥—Ä—ã:</p>
              <div className="space-y-3">
                <button
                  onClick={() => setPlayWithBot('choose')}
                  className="w-full bg-green-600 hover:bg-green-700 text-white font-semibold py-4 px-6 rounded-lg transition-colors text-lg"
                >
                  ü§ñ –ò–≥—Ä–∞ —Å –±–æ—Ç–æ–º
                </button>
                <button
                  onClick={() => startGame(false, 'white', 'medium', false)}
                  className="w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold py-4 px-6 rounded-lg transition-colors text-lg"
                >
                  üë• –ò–≥—Ä–∞ –≤–¥–≤–æ—ë–º
                </button>
                <button
                  onClick={() => startGame(false, 'white', 'medium', true)}
                  className="w-full bg-purple-600 hover:bg-purple-700 text-white font-semibold py-4 px-6 rounded-lg transition-colors text-lg"
                >
                  üéì –†–µ–∂–∏–º —Ç—Ä–µ–Ω–µ—Ä–∞
                </button>
                <button
                  onClick={() => setShowOpenings(true)}
                  className="w-full bg-amber-600 hover:bg-amber-700 text-white font-semibold py-4 px-6 rounded-lg transition-colors text-lg"
                >
                  üìö –ë–∏–±–ª–∏–æ—Ç–µ–∫–∞ –¥–µ–±—é—Ç–æ–≤
                </button>
              </div>
            </div>
          )}
          
          {playWithBot === 'choose' && (
            <div className="space-y-4">
              <h2 className="text-2xl font-bold text-center text-slate-800 mb-4">–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∏–≥—Ä—ã —Å –±–æ—Ç–æ–º</h2>
              
              <div>
                <label className="block text-sm font-semibold text-slate-700 mb-2">–í—ã–±–µ—Ä–∏—Ç–µ —Å–ª–æ–∂–Ω–æ—Å—Ç—å:</label>
                <div className="grid grid-cols-2 gap-2">
                  {Object.entries(botPersonalities).map(([key, bot]) => (
                    <button
                      key={key}
                      onClick={() => setBotDifficulty(key)}
                      className={`p-3 rounded-lg transition-all ${
                        botDifficulty === key 
                          ? 'bg-green-600 text-white ring-2 ring-green-400' 
                          : 'bg-slate-200 hover:bg-slate-300'
                      }`}
                    >
                      <div className="font-semibold">{bot.name}</div>
                      <div className="text-xs">{bot.rating} ELO</div>
                    </button>
                  ))}
                </div>
              </div>
              
              <div>
                <label className="block text-sm font-semibold text-slate-700 mb-2">–í—ã–±–µ—Ä–∏—Ç–µ —Ü–≤–µ—Ç:</label>
                <div className="grid grid-cols-3 gap-2">
                  <button
                    onClick={() => setPlayerColor('white')}
                    className={`p-3 rounded-lg transition-all ${
                      playerColor === 'white' 
                        ? 'bg-amber-600 text-white ring-2 ring-amber-400' 
                        : 'bg-slate-200 hover:bg-slate-300'
                    }`}
                  >
                    ‚ö™ –ë–µ–ª—ã–µ
                  </button>
                  <button
                    onClick={() => setPlayerColor('black')}
                    className={`p-3 rounded-lg transition-all ${
                      playerColor === 'black' 
                        ? 'bg-slate-800 text-white ring-2 ring-slate-600' 
                        : 'bg-slate-200 hover:bg-slate-300'
                    }`}
                  >
                    ‚ö´ –ß—ë—Ä–Ω—ã–µ
                  </button>
                  <button
                    onClick={() => setPlayerColor('random')}
                    className={`p-3 rounded-lg transition-all ${
                      playerColor === 'random' 
                        ? 'bg-purple-600 text-white ring-2 ring-purple-400' 
                        : 'bg-slate-200 hover:bg-slate-300'
                    }`}
                  >
                    üé≤ –°–ª—É—á–∞–π–Ω–æ
                  </button>
                </div>
              </div>
              
              <div>
                <label className="flex items-center gap-2 text-sm font-semibold text-slate-700">
                  <input
                    type="checkbox"
                    checked={trainerMode}
                    onChange={(e) => setTrainerMode(e.target.checked)}
                    className="w-4 h-4"
                  />
                  –í–∫–ª—é—á–∏—Ç—å —Ä–µ–∂–∏–º —Ç—Ä–µ–Ω–µ—Ä–∞ (–ø–æ–¥—Å–∫–∞–∑–∫–∏ –∏ –∞–Ω–∞–ª–∏–∑)
                </label>
              </div>
              
              <button
                onClick={() => startGame(true, playerColor, botDifficulty, trainerMode)}
                className="w-full bg-green-600 hover:bg-green-700 text-white font-semibold py-4 px-6 rounded-lg transition-colors text-lg mt-4"
              >
                ‚ñ∂ –ù–∞—á–∞—Ç—å –∏–≥—Ä—É
              </button>
              
              <button
                onClick={() => setPlayWithBot(false)}
                className="w-full bg-slate-400 hover:bg-slate-500 text-white font-semibold py-2 px-4 rounded-lg transition-colors"
              >
                ‚Üê –ù–∞–∑–∞–¥
              </button>
            </div>
          )}
          
          {showOpenings && (
            <div className="space-y-4 max-h-96 overflow-y-auto">
              <div className="flex justify-between items-center">
                <h2 className="text-2xl font-bold text-slate-800">üìö –î–µ–±—é—Ç—ã</h2>
                <button
                  onClick={() => setShowOpenings(false)}
                  className="text-slate-600 hover:text-slate-800"
                >
                  ‚úï
                </button>
              </div>
              {Object.entries(openingsDatabase).map(([key, opening]) => (
                <div key={key} className="bg-slate-100 p-4 rounded-lg">
                  <h3 className="font-bold text-lg text-slate-800">{opening.name}</h3>
                  <p className="text-sm text-slate-600 mt-1">{opening.description}</p>
                  {opening.moves && (
                    <div className="mt-2 text-xs text-slate-500">
                      {Object.entries(opening.moves).map(([move, name]) => (
                        <div key={move}>‚Ä¢ {name}</div>
                      ))}
                    </div>
                  )}
                </div>
              ))}
            </div>
          )}
        </div>
      </div>
    );
  }

  const currentTheme = themes[boardTheme];

  return (
    <div className="flex flex-col items-center justify-center min-h-screen bg-gradient-to-br from-slate-800 to-slate-900 p-2">
      <div className="bg-white rounded-lg shadow-2xl p-4 max-w-6xl w-full">
        <div className="flex justify-between items-center mb-3">
          <h1 className="text-2xl font-bold text-slate-800">‚ôüÔ∏è –®–∞—Ö–º–∞—Ç—ã Ultra Pro</h1>
          <div className="flex gap-2">
            {gameHistory.length > 0 && (
              <button
                onClick={() => setShowAnalysis(!showAnalysis)}
                className="bg-purple-600 hover:bg-purple-700 text-white px-3 py-1 rounded-lg transition-colors text-sm"
              >
                üìä –ê–Ω–∞–ª–∏–∑
              </button>
            )}
            <button
              onClick={() => setShowSettings(!showSettings)}
              className="bg-slate-200 hover:bg-slate-300 p-2 rounded-lg transition-colors"
            >
              ‚öôÔ∏è
            </button>
          </div>
        </div>
        
        {trainerHint && (
          <div className="bg-blue-100 border-l-4 border-blue-500 p-3 mb-3 rounded">
            <p className="text-sm text-blue-800">
              <strong>üí° –¢—Ä–µ–Ω–µ—Ä:</strong> {trainerHint}
            </p>
          </div>
        )}
        
        {currentOpening && gameHistory.length <= 10 && (
          <div className="bg-amber-100 border-l-4 border-amber-500 p-2 mb-3 rounded text-sm">
            <strong>üìñ –î–µ–±—é—Ç:</strong> {currentOpening}
          </div>
        )}
        
        {showSettings && (
          <div className="bg-slate-100 p-4 rounded-lg mb-4 space-y-3">
            <h3 className="font-semibold text-slate-800">–ù–∞—Å—Ç—Ä–æ–π–∫–∏</h3>
            
            <div>
              <label className="block text-sm font-semibold text-slate-700 mb-1">–¢–µ–º–∞ –¥–æ—Å–∫–∏:</label>
              <div className="flex gap-2 flex-wrap">
                {Object.entries(themes).map(([key, theme]) => (
                  <button
                    key={key}
                    onClick={() => setBoardTheme(key)}
                    className={`px-3 py-1 rounded text-sm ${boardTheme === key ? 'bg-blue-600 text-white' : 'bg-slate-200'}`}
                  >
                    {theme.name}
                  </button>
                ))}
              </div>
            </div>
            
            <div>
              <label className="block text-sm font-semibold text-slate-700 mb-1">–°—Ç–∏–ª—å —Ñ–∏–≥—É—Ä:</label>
              <div className="flex gap-2">
                {['classic', 'modern', 'minimal'].map(style => (
                  <button
                    key={style}
                    onClick={() => setPieceStyle(style)}
                    className={`px-3 py-1 rounded text-sm ${pieceStyle === style ? 'bg-blue-600 text-white' : 'bg-slate-200'}`}
                  >
                    {style === 'classic' ? '–ö–ª–∞—Å—Å–∏–∫–∞' : style === 'modern' ? '–°–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–π' : '–ú–∏–Ω–∏–º–∞–ª'}
                  </button>
                ))}
              </div>
            </div>
            
            <div className="flex items-center gap-4 flex-wrap">
              <label className="flex items-center gap-2">
                <input
                  type="checkbox"
                  checked={showHints}
                  onChange={(e) => setShowHints(e.target.checked)}
                  className="w-4 h-4"
                />
                <span className="text-sm">–ü–æ–¥—Å–∫–∞–∑–∫–∏</span>
              </label>
              
              <label className="flex items-center gap-2">
                <input
                  type="checkbox"
                  checked={soundEnabled}
                  onChange={(e) => setSoundEnabled(e.target.checked)}
                  className="w-4 h-4"
                />
                <span className="text-sm">–ó–≤—É–∫</span>
              </label>
              
              <label className="flex items-center gap-2">
                <input
                  type="checkbox"
                  checked={trainerMode}
                  onChange={(e) => setTrainerMode(e.target.checked)}
                  className="w-4 h-4"
                />
                <span className="text-sm">–†–µ–∂–∏–º —Ç—Ä–µ–Ω–µ—Ä–∞</span>
              </label>
            </div>
          </div>
        )}
        
        {showAnalysis && moveAnalysis.length > 0 && (
          <div className="bg-slate-100 p-4 rounded-lg mb-4">
            <h3 className="font-semibold text-slate-800 mb-3">üìä –ê–Ω–∞–ª–∏–∑ –ø–∞—Ä—Ç–∏–∏</h3>
            
            <div className="grid grid-cols-3 gap-3 mb-4">
              <div className="bg-white p-3 rounded">
                <div className="text-xs text-slate-600">–î–µ–±—é—Ç</div>
                <div className={`text-lg font-bold ${getPhaseRating(phaseScores.opening).color}`}>
                  {getPhaseRating(phaseScores.opening).text} {getPhaseRating(phaseScores.opening).emoji}
                </div>
              </div>
              <div className="bg-white p-3 rounded">
                <div className="text-xs text-slate-600">–ú–∏—Ç—Ç–µ–ª—å—à–ø–∏–ª—å</div>
                <div className={`text-lg font-bold ${getPhaseRating(phaseScores.middlegame).color}`}>
                  {getPhaseRating(phaseScores.middlegame).text} {getPhaseRating(phaseScores.middlegame).emoji}
                </div>
              </div>
              <div className="bg-white p-3 rounded">
                <div className="text-xs text-slate-600">–≠–Ω–¥—à–ø–∏–ª—å</div>
                <div className={`text-lg font-bold ${getPhaseRating(phaseScores.endgame).color}`}>
                  {getPhaseRating(phaseScores.endgame).text} {getPhaseRating(phaseScores.endgame).emoji}
                </div>
              </div>
            </div>
            
            <div className="max-h-40 overflow-y-auto space-y-1">
              {moveAnalysis.slice(-10).map((move, idx) => (
                <div key={idx} className="text-sm flex items-center gap-2 bg-white p-2 rounded">
                  <span className="font-semibold">{gameHistory.length - moveAnalysis.length + idx + 1}.</span>
                  <span>{move.notation}</span>
                  <span className={`ml-auto ${
                    move.quality === 'brilliant' ? 'text-green-600' :
                    move.quality === 'great' ? 'text-blue-600' :
                    move.quality === 'good' ? 'text-slate-600' :
                    move.quality === 'inaccuracy' ? 'text-yellow-600' :
                    move.quality === 'mistake' ? 'text-orange-600' :
                    'text-red-600'
                  }`}>
                    {move.emoji} {move.description}
                  </span>
                </div>
              ))}
            </div>
          </div>
        )}
        
        <div className="flex gap-4 flex-col lg:flex-row">
          <div>
            <div className="mb-2 text-center">
              <div className="text-base font-semibold text-slate-700">
                –•–æ–¥: {currentPlayer === 'white' ? '‚ö™ –ë–µ–ª—ã–µ' : '‚ö´ –ß—ë—Ä–Ω—ã–µ'}
                {playWithBot && currentPlayer !== playerColor && ` (${botPersonalities[botDifficulty].name})`}
              </div>
              {isCheck && !gameStatus && (
                <div className="text-red-600 font-bold text-sm">–®–∞—Ö!</div>
              )}
              {gameStatus && (
                <div className="text-lg font-bold text-green-600">{gameStatus}</div>
              )}
              {halfMoveClock > 40 && !gameStatus && (
                <div className="text-orange-600 text-xs">–•–æ–¥–æ–≤ –±–µ–∑ –≤–∑—è—Ç–∏—è: {halfMoveClock}/50</div>
              )}
            </div>
            
            <div className="inline-block border-4 border-slate-700 rounded relative">
              {board.map((row, rowIndex) => (
                <div key={rowIndex} className="flex">
                  {row.map((piece, colIndex) => {
                    const isLight = (rowIndex + colIndex) % 2 === 0;
                    const isSelected = selectedSquare && selectedSquare[0] === rowIndex && selectedSquare[1] === colIndex;
                    const isValidMove = validMoves.some(([r, c]) => r === rowIndex && c === colIndex);
                    
                    return (
                      <div
                        key={colIndex}
                        onClick={() => handleSquareClick(rowIndex, colIndex)}
                        className={`w-12 h-12 flex items-center justify-center text-3xl cursor-pointer transition-all relative
                          ${isLight ? currentTheme.light : currentTheme.dark}
                          ${isSelected ? 'ring-4 ring-blue-500 ring-inset' : ''}
                          hover:opacity-80`}
                      >
                        <span className={pieceStyle === 'minimal' ? 'text-xl font-bold' : ''}>
                          {piece && currentPieceSet[piece]}
                        </span>
                        {isValidMove && !piece && (
                          <div className="absolute w-3 h-3 bg-slate-500 rounded-full opacity-40"></div>
                        )}
                        {isValidMove && piece && (
                          <div className="absolute inset-0 border-4 border-red-500 opacity-50 rounded"></div>
                        )}
                      </div>
                    );
                  })}
                </div>
              ))}
            </div>
            
            <div className="mt-3 flex gap-2">
              <button
                onClick={undoMove}
                disabled={gameHistory.length === 0}
                className="flex-1 bg-amber-600 hover:bg-amber-700 disabled:bg-gray-400 disabled:cursor-not-allowed text-white font-semibold py-2 px-3 rounded transition-colors text-sm"
              >
                ‚Ü∂ –û—Ç–º–µ–Ω–∏—Ç—å
              </button>
              <button
                onClick={resetGame}
                className="flex-1 bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-3 rounded transition-colors text-sm"
              >
                üîÑ –ù–æ–≤–∞—è
              </button>
            </div>
          </div>
          
          <div className="flex-1 min-w-[200px]">
            <h3 className="text-base font-semibold mb-2 text-slate-700">–ò—Å—Ç–æ—Ä–∏—è —Ö–æ–¥–æ–≤:</h3>
            <div className="bg-slate-100 rounded p-3 h-96 overflow-y-auto">
              {gameHistory.length === 0 ? (
                <p className="text-slate-500 text-sm">–•–æ–¥–æ–≤ –ø–æ–∫–∞ –Ω–µ—Ç</p>
              ) : (
                gameHistory.map((move, index) => {
                  const analysis = moveAnalysis[index];
                  return (
                    <div key={index} className="text-sm py-1 border-b border-slate-300 flex items-center justify-between">
                      <span>
                        <span className="font-semibold">{Math.floor(index / 2) + 1}.</span> 
                        <span className={index % 2 === 0 ? 'text-slate-900' : 'text-slate-600'}>
                          {index % 2 === 0 ? ' ' : '... '}
                          {move.notation}
                        </span>
                      </span>
                      {analysis && (
                        <span className="text-xs">{analysis.emoji}</span>
                      )}
                    </div>
                  );
                })
              )}
            </div>
            
            <div className="mt-3 text-xs text-slate-600 space-y-1">
              <div>‚úì –í—Å–µ –ø—Ä–∞–≤–∏–ª–∞ —à–∞—Ö–º–∞—Ç</div>
              <div>‚úì 6 —É—Ä–æ–≤–Ω–µ–π —Å–ª–æ–∂–Ω–æ—Å—Ç–∏ –±–æ—Ç–∞</div>
              <div>‚úì –ê–Ω–∞–ª–∏–∑ –ø–∞—Ä—Ç–∏–∏ –∏ —Ä–µ–∂–∏–º —Ç—Ä–µ–Ω–µ—Ä–∞</div>
              <div>‚úì –ë–∏–±–ª–∏–æ—Ç–µ–∫–∞ –¥–µ–±—é—Ç–æ–≤</div>
              <div>‚úì –ü–æ–ª–Ω–∞—è –∫–∞—Å—Ç–æ–º–∏–∑–∞—Ü–∏—è</div>
            </div>
          </div>
        </div>
      </div>
      
      {showPromotionDialog && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
          <div className="bg-white p-6 rounded-lg shadow-xl">
            <h3 className="text-xl font-bold mb-4 text-center">–í—ã–±–µ—Ä–∏—Ç–µ —Ñ–∏–≥—É—Ä—É</h3>
            <div className="flex gap-3">
              {['q', 'r', 'b', 'n'].map(piece => (
                <button
                  key={piece}
                  onClick={() => {
                    makeMove(
                      showPromotionDialog.fromRow,
                      showPromotionDialog.fromCol,
                      showPromotionDialog.toRow,
                      showPromotionDialog.toCol,
                      false,
                      piece
                    );
                    setShowPromotionDialog(null);
                    setSelectedSquare(null);
                    setValidMoves([]);
                  }}
                  className="w-16 h-16 bg-slate-200 hover:bg-slate-300 rounded-lg flex items-center justify-center text-5xl transition-colors"
                >
                  {currentPieceSet[currentPlayer === 'white' ? piece.toUpperCase() : piece]}
                </button>
              ))}
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default ChessGame;
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<ChessGame />);
    </script>
</body>
</html>
